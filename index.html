<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>WebGL SDF Runtime</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: #111;
  overflow: hidden;
}
canvas {
  display: block;
}
</style>
</head>
<body>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
addEventListener("resize", resize);
resize();

/* ===== シェーダ ===== */

const vsSource = `
attribute vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

const fsSource = `
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;

/* ===== SDF ===== */

float sdCircle(vec2 p, float r) {
  return length(p) - r;
}

float sdBox(vec2 p, vec2 b) {
  vec2 d = abs(p) - b;
  return max(d.x, d.y);
}

float sdf(vec2 p) {
  float t = u_time;

  vec2 c = vec2(
    0.5 * cos(t),
    0.3 * sin(t)
  );

  float d1 = sdCircle(p - c, 0.3);
  float d2 = sdBox(p, vec2(0.2));

  // subtract
  return max(d1, -d2);
}

void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution)
            / u_resolution.y * 2.0;

  float d = sdf(uv);

  vec3 col;
  if (d < 0.0) {
    col = vec3(0.3, 0.6, 1.0);
  } else {
    float edge = exp(-d * 40.0);
    col = vec3(edge);
  }

  gl_FragColor = vec4(col, 1.0);
}
`;

/* ===== コンパイル ===== */

function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    throw gl.getShaderInfoLog(s);
  }
  return s;
}

const vs = compile(gl.VERTEX_SHADER, vsSource);
const fs = compile(gl.FRAGMENT_SHADER, fsSource);

const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
gl.useProgram(prog);

/* ===== フルスクリーンクアッド ===== */

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([
    -1,-1,  1,-1,  -1,1,
    -1,1,   1,-1,   1,1
  ]),
  gl.STATIC_DRAW
);

const loc = gl.getAttribLocation(prog, "position");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

/* ===== uniform ===== */

const uTime = gl.getUniformLocation(prog, "u_time");
const uRes  = gl.getUniformLocation(prog, "u_resolution");

/* ===== ループ ===== */

function draw(t) {
  gl.uniform1f(uTime, t * 0.001);
  gl.uniform2f(uRes, canvas.width, canvas.height);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>

</body>
</html>
